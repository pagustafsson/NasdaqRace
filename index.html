<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nasdaq 100 Bar Chart Race</title>
    <link rel="stylesheet" href="styles.css?v=2">
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>

<body>
    <div class="container">
        <h1>Nasdaq 100 Market Cap Race (30 Years)</h1>
        <div id="chart-container">
            <div id="ticker-date">Loading...</div>
            <div id="chart"></div>
        </div>
        <div class="controls">
            <button id="play-pause-btn">Play</button>
            <input type="range" id="date-slider" min="0" max="100" value="0">
            <select id="speed-selector">
                <option value="1">1x Speed</option>
                <option value="2">2x Speed</option>
                <option value="5">5x Speed</option>
                <option value="10">10x Speed</option>
            </select>
        </div>
    </div>
    <script>
        // Configuration
        const topN = 12;
        const baseDuration = 250; // ms per frame at 1x
        let duration = baseDuration;
        const width = 1000;
        const height = 600;
        const margin = { top: 20, right: 100, bottom: 30, left: 150 };

        let svg, x, y, xAxis, yAxis;
        let dateLabel;
        let tickerData = [];
        let dateList = [];
        let currentFrame = 0;
        let intervalId = null;
        let isPlaying = false;

        // Tooltip div
        const tooltip = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        // Scroll state
        let viewOffset = 0;
        let maxRank = 0;

        async function init() {
            const data = await d3.json("nasdaq_data.json?" + new Date().getTime());

            // Group data by date
            const grouped = d3.group(data, d => d.date);
            dateList = Array.from(grouped.keys()).sort();

            // Pre-process data for each frame
            tickerData = dateList.map(date => {
                let items = grouped.get(date);
                items.sort((a, b) => b.value - a.value);
                // Assign ranks
                items.forEach((d, i) => d.rank = i);
                return {
                    date: date,
                    items: items
                };
            });

            // Determine max rank for scrolling
            maxRank = d3.max(tickerData, d => d.items.length) - 1;

            setupChart();
            update(0);

            // Controls
            const btn = document.getElementById('play-pause-btn');
            const slider = document.getElementById('date-slider');
            const speedSel = document.getElementById('speed-selector');

            slider.max = dateList.length - 1;

            btn.addEventListener('click', () => {
                if (isPlaying) {
                    stopAnimation();
                } else {
                    startAnimation();
                }
            });

            slider.addEventListener('input', (e) => {
                stopAnimation();
                currentFrame = +e.target.value;
                update(currentFrame);
            });

            speedSel.addEventListener('change', (e) => {
                const speed = +e.target.value;
                duration = baseDuration / speed;
                // If playing, restart to apply new speed
                if (isPlaying) {
                    stopAnimation();
                    startAnimation();
                }
            });

            // Mouse Wheel Scrolling
            let scrollAccumulator = 0;
            const scrollThreshold = 50; // Higher = slower scroll

            d3.select(window).on("wheel", (e) => {
                // Only prevent default if we are actually scrolling the chart
                // But since body overflow is hidden, we can just prevent default always to avoid bounce
                e.preventDefault();

                scrollAccumulator += e.deltaY;

                if (Math.abs(scrollAccumulator) < scrollThreshold) return;

                const direction = scrollAccumulator > 0 ? 1 : -1;
                scrollAccumulator = 0; // Reset

                let newOffset = viewOffset + direction;

                // Clamp
                const currentTotal = tickerData[currentFrame].items.length;
                const maxOffset = Math.max(0, currentTotal - topN);

                if (newOffset < 0) newOffset = 0;
                if (newOffset > maxOffset) newOffset = maxOffset;

                if (newOffset !== viewOffset) {
                    viewOffset = newOffset;
                    // Update immediately with 0 duration to prevent "sticking" artifacts
                    update(currentFrame, 0);
                }
            });
        }

        function setupChart() {
            svg = d3.select("#chart")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            x = d3.scaleLinear()
                .range([margin.left, width - margin.right]);

            y = d3.scaleBand()
                .range([margin.top, height - margin.bottom])
                .padding(0.4);

            dateLabel = d3.select("#ticker-date");
        }

        function formatCurrency(value) {
            if (value >= 1e12) return (value / 1e12).toFixed(2) + " T";
            if (value >= 1e9) return (value / 1e9).toFixed(1) + " B";
            return (value / 1e6).toFixed(0) + " M";
        }

        function update(frameIndex, transitionDuration = duration) {
            const frameData = tickerData[frameIndex];

            // Slice data based on viewOffset
            const visibleItems = frameData.items.slice(viewOffset, viewOffset + topN);

            // Update slider and date label
            document.getElementById('date-slider').value = frameIndex;
            dateLabel.text(frameData.date);

            // Update scales
            const maxVal = visibleItems.length > 0 ? visibleItems[0].value : 0;
            x.domain([0, maxVal]);
            y.domain(d3.range(topN));

            // Bind data
            const bars = svg.selectAll(".bar-group")
                .data(visibleItems, d => d.name);

            // ENTER
            const enter = bars.enter()
                .append("g")
                .attr("class", "bar-group")
                .attr("transform", (d, i) => `translate(0, ${y(i)})`)
                .on("mouseover", function (event, d) {
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);

                    tooltip.html(d.fullname);

                    // Use client coordinates for fixed positioning
                    const x = event.clientX;
                    const y = event.clientY;

                    // Clamp to window bounds to prevent any potential overflow issues
                    // (though fixed position shouldn't trigger scroll, this is safer)
                    const windowWidth = window.innerWidth;
                    const tooltipWidth = 200; // Approx max width

                    let finalX = x;
                    if (x > windowWidth - 100) {
                        finalX = windowWidth - 100;
                    }
                    if (x < 100) {
                        finalX = 100;
                    }

                    tooltip.style("left", finalX + "px")
                        .style("top", y + "px");
                })
                .on("mouseout", function (d) {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });

            // Removed native title

            enter.append("rect")
                .attr("class", "bar")
                .attr("height", y.bandwidth())
                .attr("x", x(0))
                .attr("width", d => x(d.value) - x(0))
                .attr("fill", "#ffffff") // Always white
                .attr("rx", y.bandwidth() / 2)
                .attr("ry", y.bandwidth() / 2);

            // Rank Number (Static column)
            enter.append("text")
                .attr("class", "rank-label")
                .attr("x", margin.left - 120) // Fixed position on left
                .attr("y", y.bandwidth() / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", "start") // Left align
                .style("fill", "#888") // Grey color for rank
                .text(d => d.rank + 1);

            // Company Name
            enter.append("text")
                .attr("class", "label")
                .attr("x", margin.left - 10)
                .attr("y", y.bandwidth() / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", "end")
                .text(d => d.name);

            enter.append("text")
                .attr("class", "value")
                .attr("x", d => x(d.value) + 10)
                .attr("y", y.bandwidth() / 2)
                .attr("dy", "0.35em")
                .text(d => formatCurrency(d.value));

            // UPDATE
            const updateSelection = bars.merge(enter);

            updateSelection.transition().duration(transitionDuration).ease(d3.easeLinear)
                .attr("transform", (d, i) => `translate(0, ${y(i)})`);

            updateSelection.select(".bar")
                .transition().duration(transitionDuration).ease(d3.easeLinear)
                .attr("width", d => x(d.value) - x(0))
                .attr("fill", "#ffffff");

            updateSelection.select(".rank-label")
                .text(d => d.rank + 1); // Update rank

            updateSelection.select(".label")
                .text(d => d.name);

            // Update tooltip content if hovering during update? 
            // Usually not needed as data is bound to element.

            updateSelection.select(".value")
                .transition().duration(transitionDuration).ease(d3.easeLinear)
                .attr("x", d => x(d.value) + 10)
                .tween("text", function (d) {
                    const currentText = this.textContent;
                    let oldVal = parseFloat(currentText);

                    if (currentText.includes("T")) {
                        oldVal *= 1e12;
                    } else if (currentText.includes("B")) {
                        oldVal *= 1e9;
                    } else if (currentText.includes("M")) {
                        oldVal *= 1e6;
                    } else {
                        // Fallback or 0 if NaN
                        oldVal = oldVal || 0;
                    }

                    const i = d3.interpolateNumber(oldVal, d.value);
                    return function (t) {
                        this.textContent = formatCurrency(i(t));
                    };
                });

            // EXIT
            bars.exit()
                .remove();
        }

        function startAnimation() {
            if (isPlaying) return;
            isPlaying = true;
            document.getElementById('play-pause-btn').textContent = "Pause";

            intervalId = setInterval(() => {
                currentFrame++;
                if (currentFrame >= tickerData.length) {
                    stopAnimation();
                    currentFrame = 0; // Reset or stay at end? Let's stay at end.
                    return;
                }
                update(currentFrame);
            }, duration);
        }

        function stopAnimation() {
            isPlaying = false;
            document.getElementById('play-pause-btn').textContent = "Play";
            clearInterval(intervalId);
        }

        init();
    </script>
</body>

</html>